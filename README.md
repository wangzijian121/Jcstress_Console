# Java Concurrency Stress (jcstress) 并发测试操作台

- results : 生成的测试记录

- test_recoerd <Int> : 测试记录 

测试经过安排，以便几个线程同时执行测试，有时会在共享状态上会合。每次运行都会生成多个状态对象。然后，线程要么改变要么观察该状态对象。测试工具正在收集观察到的状态的统计数据。在许多情况下，这足以捕获并发代码的重新排序或违反合同的情况。

控制台输出可用于跟踪进度和调试。普通用户应该使用生成的 HTML 报告，该报告对结果有完整的解释。

大多数测试都是概率性的，需要大量时间来捕获所有案例。强烈建议运行更长时间的测试以获得可靠的结果。由于测试是有时间限制的，因此机器的 CPU 越快，jcstress 收集的样本就越多。工具收集的样本数量和套件运行时间之间存在权衡。有一些预设模式可以设置合理的测试持续时间，请参阅-m。许多 CI 都运行 jcstress 以-m quick加快周转速度。

测试失败并不立即意味着实现错误。通常的嫌疑是测试基础设施中的错误、测试评分错误、硬件中的错误或其他问题。分享您的结果，进行讨论，我们将找出问题所在。首先在相关邮件列表上讨论结果。

# 环境
JDK 11+


# 配置 项目 

State
State 是处理测试状态的中心注解，有这个注解的类，在测试中负责读取和修改数据。这些类要求以下两个属性:
- State 类应当是public ，而不是内部类.
- State 类应当有一个默认的构造函数.
- 
在运行期间，有State注解的类会被大量创建，因此在测试中应当尽量减少State实例的占用，所有构造函数中的操作和变量初始化代码块对所有的Actor 和Arbiter 可见。

# Expect
- ACCEPTABLE: 可接受的结果。不需要存在可接受的结果
- ACCEPTABLE_INTERESTING: 与“可接受”相同，但此结果将在报告中突出显示。
- FORBIDDEN: 禁止的结果。永远不应该存在。
- UNKNOWN: 内部期望：没有分级。请勿使用。

# Main参数
`-c<N>`:测试的并发级别。该值可以大于可用的CPU数量。<br/>
`-deoptRatio<N>`:每第N次迭代（大致）取消优化。价值较大提高了测试性能，但降低了命中率不幸的编译。<br/>
`-f[count]:`应该fork每个测试N次。“0”以嵌入模式运行偶尔分叉。<br/>
`-h`:打印此帮助。<br/>
`-iters<N>`:每次测试的迭代次数。<br/>
`-jvmArgs<字符串>`:使用给定的JVM参数。这会禁用JVM标志自动检测，并且仅运行单JVM模式。要么是单个空格分隔的选项行，或多个选项被接受。此选项仅影响分叉运行。<br/>
-jvmArgsPrepend:将给定的JVM参数添加到自动检测的前面配置。单个空格分隔的选项行，或接受多个选项。仅此选项影响分叉运行。<br/>
`-l[bool]`:列出与请求的设置匹配的可用测试。<br/>
`-m<mode>`:预设测试模式：sanity, quick, default, tough, stress.<br/>
`-maxStride<N>`:最大内部步幅大小。较大的值会降低同步开销，但也降低了准确性。<br/>
`-mf<MB>`:每个测试的最大占用空间（以兆字节为单位）。这影响步幅大小：最大足迹永远不会超出，无论最小/最大步幅大小如何。<br/>
`-minStride`:最小内部步幅大小。较大的值会降低同步开销，但也降低了准确性。<br/>
`-p<结果文件>`:在结果文件上重新运行解析器。这不会运行任何测试。<br/>
`-r<dir>`:将报告放入的目标位置。<br/>
`-sc<N>`:系统中的CPU数量。设置该值会覆盖自动检测。<br/>
`-t<regexp>`:用于测试的正则表达式选择器。<br/>
`-time<ms>`:单次测试迭代所花费的时间。较大值提高测试可靠性，因为调度程序做得更好从长远来看。<br/>
`-v`:更加详细。<br/>
`-yield[bool]`:在繁忙循环中调用Thread.yield()。<br/>
# 须知
❗内部的变量必须有一个非static修饰的变量:可以附加个private int i;否则会match找不到。